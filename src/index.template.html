<!DOCTYPE html>
<html>
    <head>
        <title>Swum</title>
        <meta charset="UTF-8">
        <meta name="author" content="Michael Gogins">
        <meta name="description" content="Visual music inspired by the interactive media works of Xiaohan Zhang.">
        <meta name="viewport" content="width=800, user-scalable=no">
        <title>Visual music by Michael Gogins</title>
        <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
        <meta http-equiv="Pragma" content="no-cache" />
        <meta http-equiv="Expires" content="0" />
        <script>
        var csound_message_callback = function(text) {
            if (typeof text === 'undefined') {
                return;
            }
            if (text === null) {
                return;
            }
            var console_ = document.getElementById('console');
            if (console_ === null) {
                console.log(text);
            } else {
                let temp = console_.innerHTML + text;
                console_.innerHTML = temp;
                console_.scrollTop = console_.scrollHeight;
            }
        }
        </script>
        <script src="csound_samples.js"></script>
        <script src="CsoundAudioNode.js"></script>
        <script src="csound_loader.js"></script>
        <script src="silencio/js/Silencio.js"></script>
        <script src="silencio/js/ChordSpace.js"></script>
        <script src="silencio/js/dat.gui.js"></script>
        <script src="silencio/js/jquery.js"></script>
        <script src="silencio/js/sprintf.js"></script>
        <script src="silencio/js/three.js"></script>
        <style>
            ::-webkit-scrollbar
            {
            width:10px;
            }
            ::-webkit-scrollbar-track-piece
            {
            background-color:transparent;
            }
            ::-webkit-scrollbar-corner
            {
            background-color:transparent;
            }
        .dg {
            font-family: Monaco, sans-serif;
            font-size:8pt;
            }
        </style>
    </head>
    <body style="background:black;">
        <table id = 'statistics' style="table-layout:fixed;z-order:10000;position:fixed;left:1vw;color:#eee;top:1vw;font-family:Monaco, sans-serif;font-size:8pt;">
            <col width=450px>
            <col width=250px>
            <tr style="color:gold;">
                <!-- Copyright (C) 2016 by Michael Gogins -->
                <td><b><i>Swum</i></b>, for Csound+HTML5</td>
                <td style="text-align:right;">Michael Gogins</td>
</tr>
            <tr>
                <td>Time:</td>
                <td id="Time_cell" style="text-align:right;color:LawnGreen;font-weight:bold;">0</td>
            </tr>
            <tr>
                <td>Chord: </td>
                <td id="Chord_cell" style="color:SkyBlue;text-align:right;"></td>
            </tr>
            <tr id='messages'>
                <td colspan="2"><textarea id="console" style="width:100%;color:SkyBlue;background-color:transparent;border:none;text-align:left;height:200px;overflow:auto;padding:0;margin:0;border-collapse:collapse;font-family:Courier, sans-serif;font-size:8pt;"></textarea></td>
            </tr>
        </table>
        <textarea class="code" id="csd" hidden rows=24 cols=80>
<CsoundSynthesizer>
<CsLicense>
Copyright (C) 2013 by Michael Gogins.
All rights reserved.
</CsLicense>
<CsOptions>
-odac -m3 -d
</CsOptions>
<CsInstruments>
sr = 48000
ksmps = 128
nchnls = 2
0dbfs = 1

connect "Blower", "outleft", "ReverbSC", "inleft"
connect "Blower", "outright", "ReverbSC", "inright"
connect "Bower", "outleft", "ReverbSC", "inleft"
connect "Bower", "outright", "ReverbSC", "inright"
connect "Buzzer", "outleft", "ReverbSC", "inleft"
connect "Buzzer", "outright", "ReverbSC", "inright"
connect "Droner", "outleft", "ReverbSC", "inleft"
connect "Droner", "outright", "ReverbSC", "inright"
connect "FMDroner", "outright", "ReverbSC", "inright"
connect "FMDroner", "outleft", "ReverbSC", "inleft"
connect "FMWaterBell", "outleft", "ReverbSC", "inleft"
connect "FMWaterBell", "outright", "ReverbSC", "inright"
;;connect "Harpsichord", "outleft", "ReverbSC", "inleft"
;;connect "Harpsichord", "outright", "ReverbSC", "inright"
connect "Phaser", "outleft", "ReverbSC", "inleft"
connect "Phaser", "outright", "ReverbSC", "inright"
connect "Sweeper", "outleft", "ReverbSC", "inleft"
connect "Sweeper", "outright", "ReverbSC", "inright"
;;connect "Xing", "outleft", "MasterOutput", "inleft"
;;connect "Xing", "outright", "MasterOutput", "inright"
;;connect "YiString", "outleft", "ReverbSC", "inleft"
;;connect "YiString", "outright", "ReverbSC", "inright"
;;connect "YiString", "chorusleft", "SolinaChorus", "inleft"
;;connect "YiString", "chorusright", "SolinaChorus", "inright"
;;connect "SolinaChorus", "outleft", "ReverbSC", "inleft"
;;connect "SolinaChorus", "outright", "ReverbSC", "inright"
connect "ReverbSC", "outleft", "MasterOutput", "inleft"
connect "ReverbSC", "outright", "MasterOutput", "inright"

alwayson "Controls"
;alwayson "SolinaChorus"
alwayson "ReverbSC"
alwayson "MasterOutput"

prealloc 1, 3
prealloc 2, 3
prealloc 3, 3
prealloc 4, 3
prealloc 5, 3

gk_Melody_midi_dynamic_range init 127
gk_Melody_level init 0
gi_Melody_chebyshev ftgen 0, 0, 65536, -7, -1, 150, 0.1, 110, 0, 252, 0
gi_Melody_sine ftgen 0, 0, 65536, 10, 1
gi_Melody_cook3 ftgen 0, 0, 65536, 10, 1, .4, 0.2, 0.1, 0.1, .05
instr Melody
; Author: Jon Nelson
; Adapted by: Michael Gogins
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_dynamic_range = i(gk_Melody_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 69
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Melody_level)
ip3 init 3.0
iattack = 0.05
isustain = p3
irelease = 0.1
xtratim iattack + irelease
ip6 = gi_Melody_chebyshev
i1 = i_frequency
k100 randi 1,10
k101 poscil 1, 5 + k100, gi_Melody_sine
ak102 linseg 0, .5, 1, p3, 1
k100 = i1 + (k101 * ak102)
; Envelope for driving oscillator.
; k1 linenr 0.5, ip3 * .3, ip3 * 2, 0.01
k1 linseg 0, ip3 * .3, .5, ip3 * 2, 0.01, isustain, 0.01, irelease, 0
; k2 line 1, p3, .5
k2 linseg 1.0, ip3, .5, isustain, .5, irelease, 0
k1 = k2 * k1
; Amplitude envelope.
k10 expseg 0.0001, iattack, 1.0, isustain, 0.8, irelease, .0001
k10 = (k10 - .0001)
; Power to partials.
k20 linseg 1.485, iattack, 1.5, (isustain + irelease), 1.485
; a1-3 are for cheby with p6=1-4
a1 poscil k1, k100 - .025, gi_Melody_cook3
; Tables a1 to fn13, others normalize,
a2 tablei a1, ip6, 1, .5
a3 balance a2, a1
; Try other waveforms as well.
a4 foscili 1, k100 + .04, 1, 2.005, k20, gi_Melody_sine
a5 poscil 1, k100, gi_Melody_sine
a6 = ((a3 * .1) + (a4 * .1) + (a5 * .8)) * k10
a7 comb a6, .5, 1 / i1
a8 = (a6 * .9) + (a7 * .1)
asignal balance a8, a1
a_declick linsegr 0, iattack, 1, isustain, 1, irelease, 0
aleft, aright pan2 asignal * i_amplitude * a_declick * k_gain, i(k_space_left_to_right)
outleta "outleft", aleft
outleta "outright", aright
prints "Melody         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Blower_grainDensity init 40
gk_Blower_grainDuration init 0.2
gk_Blower_grainAmplitudeRange init 100
gk_Blower_grainFrequencyRange init 3
gk_Blower_level init 0
gk_Blower_midi_dynamic_range init 127
gi_Blower_grtab ftgen 0, 0, 65536, 10, 1, .3, .1, 0, .2, .02, 0, .1, .04
gi_Blower_wintab ftgen 0, 0, 65536, 10, 1, 0, .5, 0, .33, 0, .25, 0, .2, 0, .167
instr Blower
//////////////////////////////////////////////
// Original by Hans Mikelson.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_dynamic_range = i(gk_Blower_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 132
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Blower_level)
iHz = i_frequency
ihertz = iHz
ip4 = i_amplitude
ip5 = iHz
ip6 = gi_Blower_grtab
ip7 = gi_Blower_wintab
ip8 = 0.033
ip8 = .002
ip9 = 150
ip9 = 100
ip10 = 1.6
ip10 = 3
idur = p3
iamp = i_amplitude ; p4
ifqc = iHz ; cpspch(p5)
igrtab = ip6
iwintab = ip7
ifrng = ip8
idens = ip9
ifade = ip10
igdur = 0.2
iattack = 0.5
i_sustain = 1000
idecay = 1.5
xtratim iattack + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, .5, iattack / 2.0, -1.5, 1, i_sustain, 0.0, 1, idecay / 2.0, 1.5, .5, idecay / 2.0, -1.5, 0
; kamp linseg 0, ifade, 1, idur - 2 * ifade, 1, ifade, 0
kamp = kenvelope
; Amp Fqc Dense AmpOff PitchOff GrDur GrTable WinTable MaxGrDur
aoutl grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
aoutr grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
a_signal = aoutl + aoutr
i_attack = .002
i_release = 0.01
xtratim i_attack + i_release
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
a_signal = a_signal * i_amplitude * a_declicking * k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
prints "Blower         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
;printks "Blower         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
endin

gk_FMWaterBell_level init 0
gi_FMWaterBell_attack init 0.002
gi_FMWaterBell_release init 0.01
gi_FMWaterBell_sustain init 20
gi_FMWaterBell_sustain_level init .1
gk_FMWaterBell_index init .5
gk_FMWaterBell_crossfade init .5
gk_FMWaterBell_vibrato_depth init 0.05
gk_FMWaterBell_vibrato_rate init 6
gk_FMWaterBell_midi_dynamic_range init 127
gi_FMWaterBell_cosine ftgen 0, 0, 65536, 11, 1
instr FMWaterBell
//////////////////////////////////////////////
// Original by Steven Yi.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
i_instrument = p1
i_time = p2
i_duration = p3
; One of the envelopes in this instrument should be releasing, and use this:
i_sustain = 1000
xtratim gi_FMWaterBell_attack + gi_FMWaterBell_release
i_midi_key = p4
i_midi_dynamic_range = i(gk_FMWaterBell_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 100
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_FMWaterBell_level)
a_signal fmbell	1, i_frequency, gk_FMWaterBell_index, gi_FMWaterBell_sustain, gk_FMWaterBell_vibrato_depth, gk_FMWaterBell_vibrato_rate, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_sustain
a_envelope transegr 0, gi_FMWaterBell_attack, -6, 1, i_sustain, -12, gi_FMWaterBell_sustain_level, gi_FMWaterBell_release, -6, 0
a_signal = a_signal * i_amplitude * a_envelope * k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
prints "FMWaterBell    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
;printks "FMWaterBell    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
endin

gk_Droner_partial1 init .5
gk_Droner_partial2 init .05
gk_Droner_partial3 init .1
gk_Droner_partial4 init .2
gk_Droner_partial5 init .1
gk_Droner_partial6 init 0
gk_Droner_partial7 init 0
gk_Droner_partial8 init 0
gk_Droner_partial9 init 0
gk_Droner_partial10 init 0
gk_Droner_level init 0
gi_Droner_waveform init 0
gi_Droner_sine ftgen 0, 0, 65536, 10, 1, 0, .02
instr Droner
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_velocity = p5
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_overall_amps = -20 + 98 + 4
i_normalization = ampdb(-i_overall_amps) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Droner_level)
k1 = gk_Droner_partial1
k2 = gk_Droner_partial2
k3 = gk_Droner_partial3
k4 = gk_Droner_partial4
k5 = gk_Droner_partial5
k6 = gk_Droner_partial6
k7 = gk_Droner_partial7
k8 = gk_Droner_partial8
k9 = gk_Droner_partial9
k10 = gk_Droner_partial10
iwaveform = gi_Droner_waveform
iattack = .5
idecay = .5
isustain = p3
xtratim iattack + idecay
aenvelope transeg 0.0, iattack / 2.0, 1.5, 1 / 2.0, iattack / 2.0, -1.5, 1, isustain, 0.0, 1, idecay / 2.0, 1.5, 1 / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(i_midi_key)
if iwaveform == 0 then
asignal poscil3 1, ihertz, gi_Droner_sine
endif
if iwaveform == 1 then
asignal vco2 1, ihertz, 8 ; integrated saw
endif
if iwaveform == 2 then
asignal vco2 1, ihertz, 12 ; triangle
endif
asignal chebyshevpoly asignal, 0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10
a_signal = asignal
i_attack = .002
i_sustain = p3
i_release = 0.01
xtratim i_attack + i_release
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
a_signal = a_signal * i_amplitude * a_declicking * k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
;printf "Droner         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", ktrigger, p1, p2, p3, p4, p5, p7, active(p1), k_out_left, k_out_right
prints "Droner         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Bower_midi_dynamic_range init 127
gk_Bower_attack init .25
gk_Bower_release init .25
gk_Bower_level init 0.5
gk_Bower_pressure init 3.75
gi_Bower_sine ftgen 0,0,65536,10,1
instr Bower
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_dynamic_range = i(gk_Bower_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 64.0
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Bower_level)
iattack = i(gk_Bower_attack)
idecay = i(gk_Bower_release)
isustain = p3
xtratim iattack + idecay
iamp = i_amplitude
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(i_midi_key)
kamp = kenvelope
kfreq = ihertz
kpres = 0.25
krat rspline 0.006,0.988,1,4
kvibf = 4.5
kvibamp = 0
iminfreq = 30
a_signal wgbow kamp,kfreq,gk_Bower_pressure,krat,kvibf,kvibamp,gi_Bower_sine,iminfreq
a_signal *= k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
prints "Bower          i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
;printks "Bower          i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
endin

gk_Phaser_attack init .125
gk_Phaser_release init .125
gk_Phaser_ratio1 init 1
gk_Phaser_ratio2 init 1/3
gk_Phaser_index1 init 2
gk_Phaser_index2 init 0.0125
gk_Phaser_level init 0.5
gk_Phaser_midi_dynamic_range init 127
gi_Phaser_sine ftgen 0,0,65536,10,1
instr Phaser
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_dynamic_range = i(gk_Phaser_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 80
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Phaser_level)
i_attack = i(gk_Phaser_attack)
i_release = i(gk_Phaser_release)
i_sustain = 1000
xtratim i_attack + i_release
a_envelope transegr 0.0, i_attack / 2.0, 1.5, i_amplitude / 2.0, i_attack / 2.0, -1.5, i_amplitude, i_sustain, 0.0, i_amplitude, i_release / 2.0, 1.5, i_amplitude / 2.0, i_release / 2.0, -1.5, 0
a1,a2 crosspm gk_Phaser_ratio1, gk_Phaser_ratio2, gk_Phaser_index1, gk_Phaser_index2, i_frequency, gi_Phaser_sine, gi_Phaser_sine
a_signal = (a1 + a2) * k_gain * a_envelope
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
prints "Phaser         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\\n", p1, p2, p3, p4, p5, p7, active(p1)
;printks "Phaser         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(aleft)), dbamp(rms(aright))
endin

gk_Buzzer_attack init .125
gk_Buzzer_release init .25
gk_Buzzer_harmonics init 8
gk_Buzzer_level init 0
gk_Buzzer_midi_dynamic_range init 127
gi_Buzzer_sine ftgen 0, 0, 65536, 10, 1
instr Buzzer
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_dynamic_range = i(gk_Buzzer_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 77
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Buzzer_level)

i_attack = i(gk_Buzzer_attack)
i_release = i(gk_Buzzer_release)
i_sustain = 1000
xtratim i_attack + i_release
a_envelope transegr 0.0, i_attack / 2.0, 1.5, i_amplitude / 2.0, i_attack / 2.0, -1.5, i_amplitude, i_sustain, 0.0, i_amplitude, i_release / 2.0, 1.5, i_amplitude / 2.0, i_release / 2.0, -1.5, 0
a_signal buzz a_envelope, i_frequency, gk_Buzzer_harmonics, gi_Buzzer_sine

a_signal = a_signal * k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
printks "Buzzer         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
prints "Buzzer         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_FMDroner_partial1 init .5
gk_FMDroner_partial2 init .05
gk_FMDroner_partial3 init .1
gk_FMDroner_partial4 init .2
gk_FMDroner_partial5 init .1
gk_FMDroner_partial6 init 0
gk_FMDroner_partial7 init 0
gk_FMDroner_partial8 init 0
gk_FMDroner_partial9 init 0
gk_FMDroner_partial10 init 0
gk_FMDroner_index init 3
gk_FMDroner_carrier init 1
gk_FMDroner_modulator init 3
gk_FMDroner_transeg_exponent init -20
gk_FMDroner_x init 6
gk_FMDroner_y init 0
gk_FMDroner_z init 0
gk_FMDroner_level init 0
gi_FMDroner_sine ftgen 0, 0, 65536, 10, 1, 0, .02
instr FMDroner
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_velocity = p5
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_overall_amps = -20 + 98 
i_normalization = ampdb(-i_overall_amps) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_FMDroner_level)
k1 = gk_FMDroner_partial1
k2 = gk_FMDroner_partial2
k3 = gk_FMDroner_partial3
k4 = gk_FMDroner_partial4
k5 = gk_FMDroner_partial5
k6 = gk_FMDroner_partial6
k7 = gk_FMDroner_partial7
k8 = gk_FMDroner_partial8
k9 = gk_FMDroner_partial9
k10 = gk_FMDroner_partial10
iattack = .5
idecay = .5
isustain = p3
xtratim iattack + idecay
aenvelope transeg 0.0, iattack / 2.0, 1.5, 1 / 2.0, iattack / 2.0, -1.5, 1, isustain, 0.0, 1, idecay / 2.0, 1.5, 1 / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(i_midi_key)
;asignal poscil3 1, ihertz, gi_FMDroner_sine
kndx transeg i(gk_FMDroner_index), i(p3), i(gk_FMDroner_transeg_exponent), 0
asignal foscili .5, ihertz, gk_FMDroner_carrier, gk_FMDroner_modulator, kndx, gi_FMDroner_sine
asignal chebyshevpoly asignal, 0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10
a_signal = asignal
i_attack = .002
i_sustain = p3
i_release = 0.01
xtratim i_attack + i_release
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
a_signal = a_signal * i_amplitude * a_declicking * k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
prints "FMDroner       i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
;printks "FMDroner       i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
endin

instr Controls
    gk_Bower_level chnget "gk_Bower_level"
    gk_Bower_pressure chnget "gk_Bower_pressure"
    gk_Blower_grainDensity chnget "gk_Blower_grainDensity"
    gk_Blower_grainDuration chnget "gk_Blower_grainDuration"
    gk_Blower_grainAmplitudeRange chnget "gk_Blower_grainAmplitudeRange"
    gk_Blower_grainFrequencyRange chnget "gk_Blower_grainFrequencyRange"
    gk_Blower_level chnget "gk_Blower_level"
    gk_Buzzer_harmonics chnget "gk_Buzzer_harmonics"
    gk_Buzzer_level chnget "gk_Buzzer_level"
    gk_Droner_partial1 chnget "gk_Droner_partial1"
    gk_Droner_partial2 chnget "gk_Droner_partial2"
    gk_Droner_partial3 chnget "gk_Droner_partial3"
    gk_Droner_partial4 chnget "gk_Droner_partial4"
    gk_Droner_partial5 chnget "gk_Droner_partial5"
    gk_Droner_level chnget "gk_Droner_level"
    gk_FMDroner_partial1 chnget "gk_FMDroner_partial1"
    gk_FMDroner_partial2 chnget "gk_FMDroner_partial2"
    gk_FMDroner_partial3 chnget "gk_FMDroner_partial3"
    gk_FMDroner_partial4 chnget "gk_FMDroner_partial4"
    gk_FMDroner_partial5 chnget "gk_FMDroner_partial5"
    gk_FMDroner_level chnget "gk_FMDroner_level"
    gk_FMWaterBell_level chnget "gk_FMWaterBell_level" 
    gi_FMWaterBell_attack chnget "gi_FMWaterBell_attack" 
    gi_FMWaterBell_release chnget "gi_FMWaterBell_release" 
    gi_FMWaterBell_sustain chnget "gi_FMWaterBell_sustain" 
    gk_FMWaterBell_index chnget "gk_FMWaterBell_index"
    gk_FMWaterBell_crossfade chnget "gk_FMWaterBell_crossfade"
    gk_FMWaterBell_vibrato_depth chnget "gk_FMWaterBell_vibrato_depth"
    gk_FMWaterBell_vibrato_rate chnget "gk_FMWaterBell_vibrato_rate"
    gk_Harpsichord_level chnget "gk_Harpsichord_level"
    gk_Harpsichord_pick chnget "gk_Harpsichord_pick"
    gk_Harpsichord_reflection chnget "gk_Harpsichord_reflection"
    gk_Harpsichord_pluck chnget "gk_Harpsichord_pluck"
    gk_MasterOutput_level chnget "gk_MasterOutput_level"
    gk_Phaser_ratio1 chnget "gk_Phaser_ratio1"
    gk_Phaser_ratio2 chnget "gk_Phaser_ratio2"
    gk_Phaser_index1 chnget "gk_Phaser_index1"
    gk_Phaser_index2 chnget "gk_Phaser_index2"
    gk_Phaser_level chnget "gk_Phaser_level"
    gk_Sweeper_britel chnget "gk_Sweeper_britel"
    gk_Sweeper_briteh chnget "gk_Sweeper_briteh"
    gk_Sweeper_britels chnget "gk_Sweeper_britels"
    gk_Sweeper_britehs chnget "gk_Sweeper_britehs"
    gk_Sweeper_level chnget "gk_Sweeper_level"
    gk_YiString_reverb_send chnget "gk_YiString_reverb_send"
    gk_YiString_cbhorus_send chnget "gk_YiString_cbhorus_send"
    gk_YiString_level chnget "gk_YiString_level"
    ;gk_SolinaChorus_chorus_lfo1_hz init .18
    ;gk_SolinaChorus_chorus_lfo1_amp init .6
    ;gk_SolinaChorus_chorus_lfo2_hz init 6
    ;gk_SolinaChorus_chorus_lfo2_amp init .2
    gk_Reverb_feedback chnget "gk_Reverb_feedback"

prints "Controls       i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\\n", p1, p2, p3, p4, p5, p7
endin


/**
 * Solina Chorus, based on Solina String Ensemble Chorus Module

   J. Haible: Triple Chorus
   http://jhaible.com/legacy/triple_chorus/triple_chorus.html

   Hugo Portillo: Solina-V String Ensemble
   http://www.native-instruments.com/en/reaktor-community/reaktor-user-library/entry/show/4525/

   Parabola tabled shape borrowed from Iain McCurdy delayStereoChorus.csd:
   http://iainmccurdy.org/CsoundRealtimeExamples/Delays/delayStereoChorus.csd

   Author: Steven Yi
   Date: 2016.05.22
   Adapted by Michael Gogins
*/
gi_solina_parabola ftgen 0, 0, 65537, 19, 0.5, 1, 180, 1
; 3 sine wave LFOs, 120 degrees out of phase
opcode sol_lfo_3, aaa, kk
kfreq, kamp xin
aphs phasor kfreq
; Funny: Function syntax does not work in this context.
a0   tablei aphs, gi_solina_parabola, 1, 0, 1
a120 tablei aphs, gi_solina_parabola, 1, 0.333, 1
a240 tablei aphs, gi_solina_parabola, 1, -0.333, 1
xout (a0 * kamp), (a120 * kamp), (a240 * kamp)
endop

opcode solina_chorus, a, akkkk
aLeft, klfo_freq1, klfo_amp1, klfo_freq2, klfo_amp2 xin
imax = 100
;; slow lfo
as1, as2, as3 sol_lfo_3 klfo_freq1, klfo_amp1
;; fast lfo
af1, af2, af3  sol_lfo_3 klfo_freq2, klfo_amp2
at1 = limit(as1 + af1 + 5, 0.0, imax)
at2 = limit(as2 + af2 + 5, 0.0, imax)
at3 = limit(as3 + af3 + 5, 0.0, imax)
a1 vdelay3 aLeft, at1, imax
a2 vdelay3 aLeft, at2, imax
a3 vdelay3 aLeft, at2, imax
xout (a1 + a2 + a3) / 3
endop

gk_SolinaChorus_chorus_lfo1_hz init .18
gk_SolinaChorus_chorus_lfo1_amp init .6
gk_SolinaChorus_chorus_lfo2_hz init 6
gk_SolinaChorus_chorus_lfo2_amp init .2
instr SolinaChorus
aleft inleta "inleft"
aright inleta "inright"
aleft solina_chorus aleft, gk_SolinaChorus_chorus_lfo1_hz, gk_SolinaChorus_chorus_lfo1_amp, gk_SolinaChorus_chorus_lfo2_hz, gk_SolinaChorus_chorus_lfo2_amp
aright solina_chorus aright, gk_SolinaChorus_chorus_lfo1_hz, gk_SolinaChorus_chorus_lfo1_amp, gk_SolinaChorus_chorus_lfo2_hz, gk_SolinaChorus_chorus_lfo2_amp
outleta "outleft", aleft
outleta "outright", aright
prints "SolinaChorus   i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Reverb_feedback init 0.975
gi_Reverb_delay_modulation init 0.875
gk_Reverb_frequency_cutoff init 15000
instr ReverbSC
aleft init 0
aright init 0
aleft inleta "inleft"
aright inleta "inright"
; aoutL, aoutR reverbsc ainL, ainR, kfblvl, kfco[, israte[, ipitchm[, iskip]]]
aleft, aright reverbsc aleft, aright, gk_Reverb_feedback, gk_Reverb_frequency_cutoff, sr, gi_Reverb_delay_modulation
outleta "outleft", aleft
outleta "outright", aright
prints "ReverbSC       i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_MasterOutput_level init 0
gS_MasterOutput_filename init ""
instr MasterOutput
aleft inleta "inleft"
aright inleta "inright"
k_gain = ampdb(gk_MasterOutput_level)
;printks2 "Master gain: %f\n", k_gain
iamp init 1
iattack init .01
idecay init 10
isustain = (60 * 6) - (iattack + idecay)
aenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
aleft butterlp aleft, 18000
aright butterlp aright, 18000
outs aleft * k_gain * aenvelope, aright * k_gain * aenvelope
; We want something that will play on my phone.
i_amplitude_adjustment = ampdbfs(-3) / 32767
i_filename_length strlen gS_MasterOutput_filename
if i_filename_length > 0 then
prints sprintf("Output filename: %s\n", gS_MasterOutput_filename)
fout gS_MasterOutput_filename, 18, aleft * i_amplitude_adjustment, aright * i_amplitude_adjustment
endif
prints "MasterOutput   i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

</CsInstruments>
<CsScore>

f 0 360

</CsScore>
</CsoundSynthesizer>
   </textarea>
    <script>
        var gui = null;
        var score_time_started = 0.;
        var score_time = 0.;
        var chord = new ChordSpace.Chord([36, 50, 55, 59, 64]);
        chord.setDuration(-1);
        chord.setVelocity(60);
        chord.setChannelsToVoices();
        var onsets = [1/16, 2/16, 3/16, 4/16, 5/16, 6/16, 7/16, 8/16, 9/16];
        //chord.setChannel(3);
        chord.setPansToVoices();
        var modality = chord.clone();
        console.log(chord.information());
        var prior_chord = chord.clone();
        var prior_score = new Silencio.Score();
        var score = new Silencio.Score();
        function updateTimeCell() {
            var score_time_cell = document.getElementById('Time_cell');
            if (typeof csound === 'undefined') {
                return;
            }
            if (csound === null) {
                return;
            }
            score_time = score_time_started - (new Date().getTime() / 1000);
            score_time_cell.innerHTML = score_time.toFixed(4);
            setTimeout(updateTimeCell, 1000);
        };
        var random_selection = function(array) {
            let index = Math.floor(Math.random() * array.length);
            return array[index];
        }
        var parameters = {
        "gk_Reverb_feedback": 0.9284424065582881,
        "gk_MasterOutput_level": 32.98040850354313,
        "gk_Blower_grainDensity": 36.73410819342804,
        "gk_Blower_grainDuration": 0.2,
        "gk_Blower_grainAmplitudeRange": 40.40751901277084,
        "gk_Blower_grainFrequencyRange": 0.033,
        "gk_Blower_level": 0.8117249154453248,
        "gk_Bower_pressure": 4.653889515219842,
        "gk_Bower_level": 3.6978579481397986,
        "gk_Buzzer_harmonics": 15,
        "gk_Buzzer_level": 0,
        "gk_Droner_partial1": 0.2254791431792559,
        "gk_Droner_partial2": 0.6674182638105975,
        "gk_Droner_partial3": 0.08117249154453213,
        "gk_Droner_partial4": 0.7215332581736189,
        "gk_Droner_partial5": 0.09019165727170236,
        "gk_Droner_level": -6.403607666290867,
        "gk_FMDroner_partial1": 0.22958817620892524,
        "gk_FMDroner_partial2": 0.23877170325728225,
        "gk_FMDroner_partial3": 0.5601951499497776,
        "gk_FMDroner_partial4": 0.1,
        "gk_FMDroner_partial5": 0.13775290572535515,
        "gk_FMDroner_level": 23.900789177001116,
        "gk_Phaser_ratio1": 1,
        "gk_Phaser_ratio2": 0.3333334,
        "gk_Phaser_index1": 1,
        "gk_Phaser_index2": 0.0125,
        "gk_Phaser_level": -19.756062562778013,
        "gi_FMWaterBell_attack": 0.002,
        "gi_FMWaterBell_release": 0.01,
        "gi_FMWaterBell_sustain": 20,
        "gk_FMWaterBell_index": 3.42728297632469,
        "gk_FMWaterBell_crossfade": 9.109357384441939,
        "gk_FMWaterBell_vibrato_depth": 0.36076662908680945,
        "gk_FMWaterBell_vibrato_rate": 6,
        "gk_FMWaterBell_level": 12.35625704622322,
        "gk_Sweeper_britel": 0.3673410819342804,
        "gk_Sweeper_briteh": 2.9,
        "gk_Sweeper_britels": 0.6612139474817047,
        "gk_Sweeper_britehs": 3.3428038456019515,
        "gk_Sweeper_level": -15.347969579566652,
        Play: function() {
                try {
                    csound = get_csound(csound_message_callback);
                    if (csound_audio_node === null) {
                         return;
                    }
                    //gui.revert();
                    let csd = document.getElementById('csd').value;
                    csound.Stop();
                    csound.SetOption("-odac")
                    csound.SetOption("--0dbfs=15")
                    csound.SetOption("--ksmps=128")
                    csound.SetOption("--nchnls=2")
                    csound.SetOption("--nchnls_i=1")
                    csound.SetOption("--sample-rate=44100")
                    csound.CompileCsdText(csd);
                    csound.Start();
                    gui.revert();
                    csound.Perform();
                    score_time_started = new Date().getTime() / 1000;
                    setTimeout(updateTimeCell, 0);
                } catch (e) {
                    alert(e);
                }
            },
            Stop: function() {
                csound.Stop();
            },
            Close: function() {
                try {
                    csound.Stop();
                    window.close();
                } catch (e) {
                    console.log(e);
                }
            },
            Hide: function() {
                $("#dat_gui").toggle();
                $("#statistics").toggle();
            },
        };        
        window.onload = function() {
            gui = new dat.GUI({width: 300});
            gui.remember(parameters);
            gui.add(parameters, 'Play').name('Play [P]');
            gui.add(parameters, 'Stop').name('Stop [S]');
            gui.add(parameters, 'Close').name('Close').name('Exit [X]');
            var Master = gui.addFolder('Master effects');
            add_slider(Master, 'gk_Reverb_feedback', 0, 1);
            add_slider(Master, 'gk_MasterOutput_level', -80, 80);
            var intruments = gui.addFolder('Instruments');
            /*
            var fmclang = intruments.addFolder('FM Clang');
            add_slider(fmclang, 'gk_FM_Clang_preset', 1, 13);
            add_slider(fmclang, 'gk_FM_Clang_level', -80, 80);
            */
            var Blower = intruments.addFolder('Blower');
            add_slider(Blower, 'gk_Blower_grainDensity', 0, 400);
            add_slider(Blower, 'gk_Blower_grainDuration', 0, .5);
            add_slider(Blower, 'gk_Blower_grainAmplitudeRange', 0, 400);
            add_slider(Blower, 'gk_Blower_grainFrequencyRange', 0, 100);
            add_slider(Blower, 'gk_Blower_level', -80, 80);
            var Bower = intruments.addFolder('Bower');
            add_slider(Bower, 'gk_Bower_pressure', 0, 6);
            add_slider(Bower, 'gk_Bower_level', -80, 80);
            var Buzzer = intruments.addFolder('Buzzer');
            add_slider(Buzzer, 'gk_Buzzer_harmonics', 0, 20);
            add_slider(Buzzer, 'gk_Buzzer_level', -80, 80);
            var Droner = intruments.addFolder('Droner');
            add_slider(Droner, 'gk_Droner_partial1', 0, 1);
            add_slider(Droner, 'gk_Droner_partial2', 0, 1);
            add_slider(Droner, 'gk_Droner_partial3', 0, 1);
            add_slider(Droner, 'gk_Droner_partial4', 0, 1);
            add_slider(Droner, 'gk_Droner_partial5', 0, 1);
            add_slider(Droner, 'gk_Droner_level', -80, 80);
            var FMDroner = intruments.addFolder('FMDroner');
            add_slider(FMDroner, 'gk_FMDroner_partial1', 0, 1);
            add_slider(FMDroner, 'gk_FMDroner_partial2', 0, 1);
            add_slider(FMDroner, 'gk_FMDroner_partial3', 0, 1);
            add_slider(FMDroner, 'gk_FMDroner_partial4', 0, 1);
            add_slider(FMDroner, 'gk_FMDroner_partial5', 0, 1);
            add_slider(FMDroner, 'gk_FMDroner_level', -80, 80);
            /*
            var Harpsichord = intruments.addFolder('Harpsichord');
            add_slider(Harpsichord, 'gk_Harpsichord_level', -80, 80);
            */
            var Phaser = intruments.addFolder('Phaser');
            add_slider(Phaser, 'gk_Phaser_ratio1', 0, 2);
            add_slider(Phaser, 'gk_Phaser_ratio2', 0, 2);
            add_slider(Phaser, 'gk_Phaser_index1', 0, 1);
            add_slider(Phaser, 'gk_Phaser_index2', 0, 1);
            add_slider(Phaser, 'gk_Phaser_level', -80, 80);
            /*
            var Xing = intruments.addFolder('Xing');
            add_slider(Xing, 'gk_Xing_level', -80, 80);
            var Shiner = intruments.addFolder('Shiner');
            add_slider(Shiner, 'gk_Shiner_level', -80, 80);
            */
            var FMWaterBell = intruments.addFolder('FMWaterBell');
            add_slider(FMWaterBell, 'gi_FMWaterBell_attack', 0, 1);
            add_slider(FMWaterBell, 'gi_FMWaterBell_release', 0, 1);
            add_slider(FMWaterBell, 'gi_FMWaterBell_sustain', 0, 50);
            add_slider(FMWaterBell, 'gk_FMWaterBell_index', 0, 10);
            add_slider(FMWaterBell, 'gk_FMWaterBell_crossfade', 0, 10);
            add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_depth', 0, 4);
            add_slider(FMWaterBell, 'gk_FMWaterBell_crossfade', 0, 10);
            add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_rate', 0, 6);
            add_slider(FMWaterBell, 'gk_FMWaterBell_level', -80, 80);
            
            var Sweeper = intruments.addFolder('Sweeper');
            add_slider(Sweeper, 'gk_Sweeper_britel', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_briteh', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_britels', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_britehs', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_level', -80, 80);
            gui.revert();
            gui.domElement.id = 'dat_gui';
        }
        function gk_update(name, value) {
            if (typeof csound !== 'undefined' && csound !== null) {
                var numberValue = parseFloat(value);
                csound.SetControlChannel(name, numberValue);
                csound.Message(name + ': ' + numberValue + '\n');
            }
        }
        function add_slider(gui_folder, token, minimum, maximum) {
            var on_parameter_change = function(value) {
                if (token.startsWith('gk_')) {
                    gk_update(token, value);
                } 
            };
            var slider = gui_folder.add(parameters, token, minimum, maximum);
            slider.onChange(on_parameter_change);
            return slider;
        };
        // Used to find out what actually happens when a key is pressed.
        function printKey(e) {
          e = e || event
          //if (document.forms.keyform[e.type + 'Ignore'].checked) return
          var evt = e.type
          while (evt.length < 10) evt += ' ';
          var data = evt +
            ' keyCode=' + e.keyCode +
            ' which=' + e.which +
            ' charCode=' + e.charCode +
            ' char=' + String.fromCharCode(e.keyCode || e.charCode) +
            (e.shiftKey ? ' +shift' : '') +
            (e.ctrlKey ? ' +ctrl' : '') +
            (e.altKey ? ' +alt' : '') +
            (e.metaKey ? ' +meta' : '') + '\n';
          //var message = {data: data};
          //logMessage(message);
        }
        keyed_value = 0;
        keyed_sign = 1;
        $(document).on("keydown", function (e) {
            //printKey(e);
            if (e.key !== "F11") {
                e.preventDefault();
                e.stopPropagation();
            }
            if (e.shiftKey === true) {
                keyed_sign = -1;
            } else {
                keyed_sign = 1;
            }
            var e_char = String.fromCharCode(e.keyCode || e.charCode);
            // Numbers (and pitch-classes) are 0 through b.
            // Shift key changes from 1 to -1.
            if (e.ctrlKey === true) {
                keyed_value = e.which - 48;
                if (keyed_value > 9) {
                    keyed_value -= 7;
                }
                keyed_value *= keyed_sign;
            } else {
                if        (e_char === 'A') {
                    // Turn off prior chord.
                    prior_score.clear();
                    ChordSpace.insert(prior_score, prior_chord, 0);
                    prior_score.turnoffInCsound(csound);
                    // Turn on current chord with indefinite duration.
                    score.clear();
                    chord = chord.er(72).T(24);
                    // console.log(chord.information());
                    ChordSpace.insert(score, chord, 0);
                    // Arpeggiate the chord.
                    let i;
                    let n = chord.size();
                    onset = 0;
                    for (i = 0; i < n; i++) {
                        onset += random_selection(onsets) * 2;
                        score.data[i].time = onset;
                    }
                    score.sendToCsound(csound);
                    // Save current chord as prior chord.
                    prior_chord = chord.clone();
                    let name = chord.toName();
                    flame.updateName(name);
                    let chord_cell = document.getElementById("Chord_cell");
                    chord_cell.innerHTML = name;
                } else if (e_char === 'C') {
                    // Turn off prior chord.
                    prior_score.clear();
                    ChordSpace.insert(prior_score, prior_chord, 0);
                    prior_score.turnoffInCsound(csound);
                    // Turn on current chord with indefinite duration.
                    score.clear();
                    chord = chord.er(72).T(24);
                    // console.log(chord.information());
                    ChordSpace.insert(score, chord, 0);
                    score.sendToCsound(csound);
                    // Save current chord as prior chord.
                    prior_chord = chord.clone();
                    let name = chord.toName();
                    flame.updateName(name);
                    let chord_cell = document.getElementById("Chord_cell");
                    chord_cell.innerHTML = name;
                } else if (e_char === 'D') {
                    chord = chord.T(5);
                } else if (e_char === 'H') {
                    parameters.Hide();
                } else if (e_char === 'I') {
                    chord = chord.I();
                } else if (e_char === 'K') {
                    chord = chord.K();
                } else if (e_char === 'L') {
                    let velocity = chord.getVelocity();
                    velocity = velocity + (4 * keyed_sign);
                    chord.setVelocity(velocity);
                } else if (e_char === 'P') {
                    parameters.Play();
                } else if (e_char === 'Q') {
                    chord = chord.Q(1, modality);
                } else if (e_char === 'R') {
                    let i;
                    let n = Math.abs(keyed_value);
                    for (i = 0; i < n; i++) {
                        chord = chord.v(keyed_sign);
                    }
                } else if (e_char === 'S') {
                    parameters.Stop();
                } else if (e_char === 'T') {
                    chord = chord.T(1 * keyed_sign);
                } else if (e_char === 'V') {
                    // Turn off prior chord.
                    prior_score.clear();
                    ChordSpace.insert(prior_score, prior_chord, 0);
                    prior_score.turnoffInCsound(csound);
                    // Turn on current chord with indefinite duration.
                    score.clear();
                    chord = ChordSpace.voiceleadingClosestRange(prior_chord, chord, 72, true);
                    // console.log(chord.information());
                    ChordSpace.insert(score, chord, 0);
                    score.sendToCsound(csound);
                    // Save current chord as prior chord.
                    prior_chord = chord.clone();
                    let name = chord.toName();
                    flame.updateName(name);
                } else if (e_char === 'W') {
                    // First revoice.
                    let i;
                    let n = Math.abs(keyed_value);
                    for (i = 0; i < n; i++) {
                        chord = chord.v(keyed_sign);
                    }
                    // Then turn off prior chord.
                    prior_score.clear();
                    ChordSpace.insert(prior_score, prior_chord, 0);
                    prior_score.turnoffInCsound(csound);
                    // Turn on current chord with indefinite duration.
                    score.clear();
                    chord = chord.er(72).T(24);
                    // console.log(chord.information());
                    ChordSpace.insert(score, chord, 0);
                    score.sendToCsound(csound);
                    // Save current chord as prior chord.
                    prior_chord = chord.clone();
                    let name = chord.toName();
                    flame.updateName(name);
                    let chord_cell = document.getElementById("Chord_cell");
                    chord_cell.innerHTML = name;
                }
            }
        });
        </script>
    </body>
</html>        
